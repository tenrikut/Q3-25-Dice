use anchor_lang::{
    prelude::*,
    system_program::{transfer, Transfer},
};

use crate::{error::DiceError, Bet, MAX_BET_LAMPORTS, MAX_ROLL, MIN_BET_LAMPORTS, MIN_ROLL};

/// Place Bet Instruction - Allows players to place new dice bets
///
/// This instruction creates a new bet account and transfers the bet amount
/// from the player to the house vault. The bet will await resolution through
/// the resolve_bet instruction using Ed25519 signatures for randomness.
#[derive(Accounts)]
#[instruction(seed:u128)] // This attribute makes the seed available in account constraints
pub struct PlaceBet<'info> {
    /// The player placing the bet
    /// Must sign the transaction and have sufficient SOL for the bet amount
    #[account(mut)]
    pub player: Signer<'info>,

    /// House authority (unchecked for efficiency)
    /// Used only for vault PDA seed derivation, not for authorization
    /// The actual authorization happens through the vault PDA constraints
    ///CHECK: This check is safe
    pub house: UncheckedAccount<'info>,

    /// The house vault that will receive the bet amount
    /// Must match the PDA derived from the house authority
    ///
    /// Seeds: ["vault", house_pubkey]
    #[account(
        mut,
        seeds = [b"vault",house.key().as_ref()],
        bump
    )]
    pub vault: SystemAccount<'info>,

    /// The bet account to be created for this specific bet
    /// Each bet gets its own PDA to store bet details
    ///
    /// Seeds: ["bet", player_pubkey, seed_bytes]
    /// - The seed parameter allows players to have multiple concurrent bets
    /// - Each combination of player + seed creates a unique bet account
    /// - Space is calculated using Anchor's InitSpace derive macro
    #[account(
        init,
        payer = player,
        space = 8 + Bet::INIT_SPACE,
        seeds = [b"bet", player.key().as_ref(), seed.to_le_bytes().as_ref()],
        bump
    )]
    pub bet: Account<'info, Bet>,

    /// Randomness account provided by an oracle service
    /// Used to link this bet to a specific randomness source
    /// The account data is validated manually in the handler
    /// CHECK: The account's data is validated manually within the handler.
    pub randomness_account: AccountInfo<'info>,

    /// System program required for account creation and SOL transfers
    pub system_program: Program<'info, System>,
}

impl<'info> PlaceBet<'info> {
    /// Create a new bet with the specified parameters
    ///
    /// # Arguments
    /// * `amount` - Bet amount in lamports (must be within MIN/MAX limits)
    /// * `roll` - Player's roll prediction (2-96, player wins if random < roll)
    /// * `seed` - Unique seed to allow multiple bets from the same player
    /// * `randomness_account` - Public key of the randomness oracle account
    /// * `bumps` - PDA bumps generated by Anchor
    ///
    /// # Returns
    /// * `Result<()>` - Success or validation error
    ///
    /// # Game Mechanics
    /// - Player wins if the random roll (1-100) is LESS than their prediction
    /// - Higher predictions = higher win chance but lower payout multiplier
    /// - Payout formula: (bet_amount * house_edge_factor) / (prediction - 1)
    pub fn create_bet(
        &mut self,
        amount: u64,
        roll: u8,
        seed: u128,
        randomness_account: Pubkey,
        bumps: &PlaceBetBumps,
    ) -> Result<()> {
        // VALIDATION: Check bet amount is within allowed limits
        if amount < MIN_BET_LAMPORTS {
            return Err(DiceError::MinimumBet.into());
        }
        if amount > MAX_BET_LAMPORTS {
            return Err(DiceError::MaximumBet.into());
        }

        // VALIDATION: Check roll prediction is within valid range
        // Roll must be 2-96 to ensure both winning and losing outcomes are possible
        if roll < MIN_ROLL {
            return Err(DiceError::MinimumRoll.into());
        }
        if roll > MAX_ROLL {
            return Err(DiceError::MaximumRoll.into());
        }

        // VALIDATION: Check if this bet account already has an unresolved bet
        // This prevents overwriting existing active bets
        if self.bet.is_resolved == false
            && self.bet.commit_slot != 0
            && self.bet.key() != Pubkey::default()
        {
            return Err(DiceError::BetAlreadyPlaced.into());
        }

        // TRANSFER: Move bet amount from player to house vault
        let accounts = Transfer {
            from: self.player.to_account_info(),
            to: self.vault.to_account_info(),
        };

        let ctx = CpiContext::new(self.system_program.to_account_info(), accounts);
        transfer(ctx, amount)?;

        // INITIALIZE: Set up the bet account with all relevant data
        self.bet.set_inner(Bet {
            amount,                          // Bet amount in lamports
            player: self.player.key(),       // Player's public key
            slot: Clock::get()?.slot,        // Current slot when bet was placed
            seed,                            // Unique seed for this bet
            roll,                            // Player's roll prediction
            bump: bumps.bet,                 // PDA bump for this bet account
            randomness_account,              // Oracle account for randomness
            commit_slot: Clock::get()?.slot, // Slot when bet was committed
            is_resolved: false,              // Bet is pending resolution
        });

        Ok(())
    }
}
